<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Multiplicat</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Use UMD builds of React for global access -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel for JSX compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<style>
  @keyframes score-bounce {
    0% { transform: scale(1); }
    30% { transform: scale(1.4); }
    60% { transform: scale(0.9); }
    80% { transform: scale(1.1); }
    100% { transform: scale(1); }
  }
  .animate-score-bounce {
    animation: score-bounce 0.6s ease-in-out;
  }
  @keyframes draw-line {
    from {
      stroke-dashoffset: 1000;
    }
    to {
      stroke-dashoffset: 0;
    }
  }
  .animate-draw-line {
    stroke-dasharray: 1000;
    animation: draw-line 0.8s ease-out forwards;
  }
  @keyframes fade-in-down {
    from {
      opacity: 0;
      transform: translateY(-20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  .animate-fade-in-down {
    animation: fade-in-down 0.5s ease-out forwards;
  }
  @keyframes pulse-highlight {
    0%, 100% {
      transform: scale(1.05);
    }
    50% {
      transform: scale(1.15);
    }
  }
  .animate-pulse-highlight {
    animation: pulse-highlight 0.8s ease-in-out 2;
    z-index: 10;
  }
  @keyframes score-popup-animation {
    0% {
      opacity: 0;
      transform: translateY(0) scale(0.5);
    }
    20%, 80% {
      opacity: 1;
      transform: translateY(-20px) scale(1);
    }
    100% {
      opacity: 0;
      transform: translateY(-40px) scale(0.8);
    }
  }
  .animate-score-popup {
    animation: score-popup-animation 2s ease-out forwards;
  }
  @keyframes pulse-line {
    0%, 100% {
      stroke-width: 10;
      filter: drop-shadow(0 0 4px rgba(255, 255, 255, 0.6));
    }
    50% {
      stroke-width: 14;
      filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.9));
    }
  }
  .animate-pulse-line {
    animation: pulse-line 0.8s ease-in-out 2;
    animation-delay: 0.5s; /* Delay to let the drawing animation start */
  }
  @keyframes pulse-ring-opacity {
    0%, 100% {
      --tw-ring-opacity: 0.5;
    }
    50% {
      --tw-ring-opacity: 1;
    }
  }
  .animate-pulse-ring {
    animation: pulse-ring-opacity 2s infinite ease-in-out;
  }
  @keyframes flash-red {
      0%, 100% {
          box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); /* red-500 with 0 opacity */
      }
      50% {
          box-shadow: 0 0 0 8px rgba(239, 68, 68, 0.6); /* red-500 with some opacity */
      }
  }
  .animate-flash-red {
      animation: flash-red 0.8s ease-out 2;
  }
</style>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
<body class="bg-slate-100 dark:bg-slate-900">
    <div id="root"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <script type="text/babel">
// Bundled application code
// All imports/exports have been removed and files are ordered by dependency.

// ===== From types.ts =====
// type Player = 'Rouge' | 'Bleu' | 'Vert';
// interface CellData { number: number; owner: Player | null; }
// type GameBoard = CellData[][];
// type GameLevel = 1 | 2 | 3;
// type GameState = 'setup' | 'playing' | 'gameOver';
// interface Scores { Rouge: number; Bleu: number; Vert: number; }
// interface Move { player: Player; number: number; factor1: number; factor2: number; }
// type Role = 'attacker' | 'defender' | null;
// interface Coordinate { r: number; c: number; }
// interface WinningLine { player: Player; coords: Coordinate[]; }
// interface AiMove { r: number; c: number; factor2: number; }
// type AiDifficulty = 1 | 2 | 3;
// interface PlayerConfig { isAi: boolean; difficulty: AiDifficulty; name: string; }

// ===== From constants.ts =====
const PLAYER_COLORS = {
  Rouge: { base: 'bg-red-500', text: 'text-red-500', ring: 'ring-red-500' },
  Bleu: { base: 'bg-blue-500', text: 'text-blue-500', ring: 'ring-blue-500' },
  Vert: { base: 'bg-green-500', text: 'text-green-500', ring: 'ring-green-500' },
};
const LEVEL_CONFIG = {
  1: { attackerRange: { min: 2, max: 10 }, defenderRange: { min: 1, max: 10 }, description: "Les bases : tables de 2 à 10. Parfait pour s'entraîner." },
  2: { attackerRange: { min: 6, max: 9 }, defenderRange: { min: 1, max: 9 }, description: "On corse les choses : tables de 6 à 9 pour un défi plus relevé." },
  3: { attackerRange: { min: 6, max: 12 }, defenderRange: { min: 1, max: 12 }, description: "Défi des experts : tables de 6 à 12, incluant les tables de 11 et 12." },
};
const POINTS_MAP = {
  3: 1,
  4: 3,
  5: 10,
};

// ===== From utils.ts =====
const generateBoard = (level, gridSize, numPlayers) => {
  let { attackerRange, defenderRange } = { ...LEVEL_CONFIG[level] };
  if (numPlayers === 3) {
    attackerRange = { ...attackerRange, min: Math.max(attackerRange.min, 4) };
    defenderRange = { ...defenderRange, min: Math.max(defenderRange.min, 4) };
  }
  const products = [];
  for (let i = attackerRange.min; i <= attackerRange.max; i++) {
    for (let j = defenderRange.min; j <= defenderRange.max; j++) {
      products.push(i * j);
    }
  }
  let productPool;
  const uniqueProducts = Array.from(new Set(products));
  if (numPlayers === 3) {
    productPool = [...uniqueProducts, ...uniqueProducts];
  } else {
    productPool = uniqueProducts;
  }
  const shuffledProducts = productPool.sort(() => 0.5 - Math.random());
  let boardNumbers = shuffledProducts.slice(0, gridSize * gridSize);
  if (numPlayers === 3 && boardNumbers.length < gridSize * gridSize) {
    const needed = gridSize * gridSize - boardNumbers.length;
    if (uniqueProducts.length > 0) {
      for (let i = 0; i < needed; i++) {
        boardNumbers.push(uniqueProducts[i % uniqueProducts.length]);
      }
    }
  }
  const board = [];
  for (let i = 0; i < gridSize; i++) {
    const row = [];
    for (let j = 0; j < gridSize; j++) {
      row.push({
        number: boardNumbers[i * gridSize + j] || 0,
        owner: null,
      });
    }
    board.push(row);
  }
  return board;
};
const scoreLine = (line) => {
    const scores = {};
    let i = 0;
    while (i < line.length) {
        const player = line[i];
        if (player === null) {
            i++;
            continue;
        }
        let j = i;
        while (j < line.length && line[j] === player) {
            j++;
        }
        const streakLength = j - i;
        if (streakLength >= 3) {
            const points = POINTS_MAP[Math.min(streakLength, 5)];
            if (points) {
               scores[player] = (scores[player] || 0) + points;
            }
        }
        i = j;
    }
    return scores;
};
const calculateScores = (board) => {
  const totalScores = { Rouge: 0, Bleu: 0, Vert: 0 };
  if (board.length === 0) return totalScores;
  const size = board.length;
  const updateScores = (lineScores) => {
    for (const player in lineScores) {
      totalScores[player] += lineScores[player];
    }
  };
  for (let r = 0; r < size; r++) {
    const row = board[r].map(cell => cell.owner);
    updateScores(scoreLine(row));
  }
  for (let c = 0; c < size; c++) {
    const col = board.map(row => row[c].owner);
    updateScores(scoreLine(col));
  }
  for (let k = 0; k < size * 2 - 1; k++) {
    const d1 = [];
    const d2 = [];
    for (let j = 0; j <= k; j++) {
      const i = k - j;
      if (i < size && j < size) {
        d1.push(board[i][j].owner);
        d2.push(board[i][size - 1 - j].owner);
      }
    }
    if (d1.length >= 3) updateScores(scoreLine(d1));
    if (d2.length >= 3) updateScores(scoreLine(d2));
  }
  return totalScores;
};
const findLineStreaks = (line) => {
    const winningLines = [];
    let i = 0;
    while (i < line.length) {
        const cell = line[i];
        const player = cell.owner;
        if (player === null) {
            i++;
            continue;
        }
        let j = i;
        while (j < line.length && line[j].owner === player) {
            j++;
        }
        const streakLength = j - i;
        if (streakLength >= 3) {
           const coords = [];
           for (let k = i; k < j; k++) {
                coords.push({ r: line[k].r, c: line[k].c });
           }
           winningLines.push({ player, coords });
        }
        i = j;
    }
    return winningLines;
};
const findWinningLines = (board) => {
  const allLines = [];
  if (board.length === 0) return [];
  const size = board.length;
  for (let r = 0; r < size; r++) {
    const row = board[r].map((cell, c) => ({ owner: cell.owner, r, c }));
    allLines.push(...findLineStreaks(row));
  }
  for (let c = 0; c < size; c++) {
    const col = board.map((row, r) => ({ owner: row[c].owner, r, c }));
     allLines.push(...findLineStreaks(col));
  }
  for (let k = 0; k < size * 2 - 1; k++) {
    const d1 = [];
    const d2 = [];
    for (let c = 0; c <= k; c++) {
      const r = k - c;
      if (r < size && c < size) {
        d1.push({ owner: board[r][c].owner, r, c});
        d2.push({ owner: board[r][size - 1 - c].owner, r, c: size - 1 - c});
      }
    }
     if (d1.length >= 3) allLines.push(...findLineStreaks(d1));
     if (d2.length >= 3) allLines.push(...findLineStreaks(d2));
  }
  return allLines;
};
const getValidAiMoves = (board, attackingFactor, defenderRange) => {
    const moves = [];
    board.forEach((row, r) => {
        row.forEach((cell, c) => {
            if (cell.owner === null) {
                if (cell.number % attackingFactor === 0) {
                    const factor2 = cell.number / attackingFactor;
                    if (factor2 >= defenderRange.min && factor2 <= defenderRange.max) {
                        moves.push({ r, c, factor2 });
                    }
                }
            }
        });
    });
    return moves;
};
const aiSelectFactor = (availableFactors) => {
    if (availableFactors.length === 0) return 0;
    return availableFactors[Math.floor(Math.random() * availableFactors.length)];
};
const aiFindBestMoveLevel1 = (validMoves) => {
    if (validMoves.length === 0) return null;
    return validMoves[Math.floor(Math.random() * validMoves.length)];
};
const aiFindBestMoveLevel2 = (board, validMoves, aiPlayer) => {
    if (validMoves.length === 0) return null;
    const checkMoveForNewLine = (r, c) => {
        const tempBoard = JSON.parse(JSON.stringify(board));
        tempBoard[r][c].owner = aiPlayer;
        const newLines = findWinningLines(tempBoard).filter(l => l.player === aiPlayer);
        const originalLines = findWinningLines(board).filter(l => l.player === aiPlayer);
        return newLines.length > originalLines.length;
    };
    for (const move of validMoves) {
        if (checkMoveForNewLine(move.r, move.c)) {
            return move;
        }
    }
    return validMoves[Math.floor(Math.random() * validMoves.length)];
};
const aiFindBestMoveLevel3 = (board, validMoves, aiPlayer, humanPlayer) => {
    if (validMoves.length === 0) return null;
    const originalAiLines = findWinningLines(board).filter(l => l.player === aiPlayer);
    const originalHumanLines = findWinningLines(board).filter(l => l.player === humanPlayer);
    const checkMove = (r, c, player) => {
        const tempBoard = JSON.parse(JSON.stringify(board));
        tempBoard[r][c].owner = player;
        const newLines = findWinningLines(tempBoard).filter(l => l.player === player);
        const originalLines = player === aiPlayer ? originalAiLines : originalHumanLines;
        return newLines.length > originalLines.length;
    };
    for (const move of validMoves) {
        if (checkMove(move.r, move.c, aiPlayer)) {
            return move;
        }
    }
    for (const move of validMoves) {
        if (checkMove(move.r, move.c, humanPlayer)) {
            return move;
        }
    }
    return validMoves[Math.floor(Math.random() * validMoves.length)];
};
const findBestAiMove = (board, attackingFactor, defenderRange, aiPlayer, opponents, difficulty) => {
    const validMoves = getValidAiMoves(board, attackingFactor, defenderRange);
    if (validMoves.length === 0) return null;
    switch (difficulty) {
        case 1:
            return aiFindBestMoveLevel1(validMoves);
        case 2:
            return aiFindBestMoveLevel2(board, validMoves, aiPlayer);
        case 3:
        default:
            const primaryOpponent = opponents[0];
            if (!primaryOpponent) return aiFindBestMoveLevel1(validMoves);
            return aiFindBestMoveLevel3(board, validMoves, aiPlayer, primaryOpponent);
    }
};

// ===== From components =====
const AnimatedScore = ({ targetScore }) => {
  const { useState, useEffect, useRef } = React;
  const [displayedScore, setDisplayedScore] = useState(targetScore);
  const [isAnimating, setIsAnimating] = useState(false);
  const animationFrameId = useRef(null);
  const prevTargetScore = useRef(targetScore);
  useEffect(() => {
    if (prevTargetScore.current === targetScore) {
      return;
    }
    const startScore = prevTargetScore.current;
    const duration = 800;
    let startTime = null;
    if (targetScore > startScore) {
      setIsAnimating(true);
    }
    const animate = (timestamp) => {
      if (!startTime) {
        startTime = timestamp;
      }
      const elapsed = timestamp - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const newDisplayValue = Math.round(startScore + (targetScore - startScore) * progress);
      setDisplayedScore(newDisplayValue);
      if (progress < 1) {
        animationFrameId.current = requestAnimationFrame(animate);
      } else {
        setIsAnimating(false);
        setDisplayedScore(targetScore);
      }
    };
    animationFrameId.current = requestAnimationFrame(animate);
    prevTargetScore.current = targetScore;
    return () => {
      if (animationFrameId.current) {
        cancelAnimationFrame(animationFrameId.current);
      }
    };
  }, [targetScore]);
  useEffect(() => {
    return () => {
      prevTargetScore.current = displayedScore;
    };
  }, [displayedScore]);
  const animationClass = isAnimating ? 'text-green-500 animate-score-bounce' : 'text-slate-700 dark:text-slate-200';
  return (
    React.createElement('span', { className: `inline-block text-3xl font-black transition-colors duration-300 ${animationClass}` }, displayedScore)
  );
};

const ScorePopup = ({ points, style }) => {
  return (
    React.createElement('div', { style: style, className: "absolute z-20 pointer-events-none animate-score-popup" },
      React.createElement('div', { className: "px-4 py-2 bg-yellow-400 text-yellow-900 font-bold text-lg rounded-full shadow-lg border-4 border-white" }, `+${points} points !`)
    )
  );
};

const WinningLinesOverlay = ({ lines, highlightedLines, gridSize, is3P, cellSize, getCellPosition }) => {
  if (lines.length === 0 || cellSize === 0) {
    return React.createElement('div', { className: "absolute inset-0 pointer-events-none" });
  }
  const generateLineKey = (line) => {
    const start = line.coords[0];
    const end = line.coords[line.coords.length - 1];
    const coord1Str = `${start.r},${start.c}`;
    const coord2Str = `${end.r},${end.c}`;
    const sortedCoords = [coord1Str, coord2Str].sort();
    return `${line.player}:${sortedCoords[0]}:${sortedCoords[1]}`;
  };
  const getCellCenter = (r, c) => {
    const { top, left } = getCellPosition(r,c);
    return { x: left + cellSize / 2, y: top + cellSize / 2 };
  };
  const highlightedLineKeys = new Set(highlightedLines.map(generateLineKey));
  return (
    React.createElement('div', { className: "absolute inset-0 pointer-events-none" },
      React.createElement('svg', { width: "100%", height: "100%", style: { overflow: 'visible' } },
        lines.map((line) => {
          if (line.coords.length < 2) return null;
          const key = generateLineKey(line);
          const isHighlighted = highlightedLineKeys.has(key);
          const startCell = line.coords[0];
          const endCell = line.coords[line.coords.length - 1];
          const startPoint = getCellCenter(startCell.r, startCell.c);
          const endPoint = getCellCenter(endCell.r, endCell.c);
          const color = PLAYER_COLORS[line.player].ring.replace('ring-', '');
          const animationClass = isHighlighted ? "animate-draw-line animate-pulse-line" : "";
          const strokeWidth = isHighlighted ? "10" : "8";
          return (
            React.createElement('line', {
              key: key, x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y,
              stroke: color, strokeWidth: strokeWidth, strokeLinecap: "round", className: animationClass
            })
          );
        })
      )
    )
  );
};

const GameBoardComponent = ({ board, numPlayers, winningLines, onCellClick, disabled, defender, scorePopup, incorrectCell, highlightedLines }) => {
  const { useRef, useState, useLayoutEffect } = React;
  const gridRef = useRef(null);
  const [cellSize, setCellSize] = useState(0);
  const [containerSize, setContainerSize] = useState({width: 0, height: 0});
  const isHexagonalLayout = numPlayers === 3;
  const gridSize = board.length;

  useLayoutEffect(() => {
    const container = gridRef.current;
    if (!container) return;
    const resizeObserver = new ResizeObserver(entries => {
        for (let entry of entries) {
            const containerWidth = entry.contentRect.width;
            if (gridSize <= 0) return;
            let newCellSize = 0;
            let newContainerHeight = 0;
            if (isHexagonalLayout) {
                const STAGGER_OFFSET_IN_CELLS = 0.5;
                const effectiveGridWidthInCells = gridSize + STAGGER_OFFSET_IN_CELLS;
                newCellSize = containerWidth / effectiveGridWidthInCells;
                const HEX_VERTICAL_SPACING_RATIO = Math.sqrt(3) / 2;
                const rowHeight = newCellSize * HEX_VERTICAL_SPACING_RATIO;
                newContainerHeight = newCellSize + (gridSize - 1) * rowHeight;
            } else {
                const GAP_TO_CELL_RATIO = 0.2;
                const totalDivisions = gridSize * (1 + GAP_TO_CELL_RATIO);
                newCellSize = containerWidth / totalDivisions;
                newContainerHeight = containerWidth;
            }
            setCellSize(newCellSize);
            setContainerSize({ width: containerWidth, height: newContainerHeight });
        }
    });
    resizeObserver.observe(container);
    return () => resizeObserver.disconnect();
  }, [gridSize, isHexagonalLayout]);
  
  const getCellPosition = (r, c) => {
      if (cellSize === 0) return { top: 0, left: 0 };
      if (isHexagonalLayout) {
        const STAGGER_OFFSET_IN_CELLS = 0.5;
        const HEX_VERTICAL_SPACING_RATIO = Math.sqrt(3) / 2;
        const isStaggeredRow = r % 2 !== 0;
        const horizontalOffset = isStaggeredRow ? cellSize * STAGGER_OFFSET_IN_CELLS : 0;
        const rowHeight = cellSize * HEX_VERTICAL_SPACING_RATIO;
        return { top: r * rowHeight, left: c * cellSize + horizontalOffset };
      } else {
        const GAP_TO_CELL_RATIO = 0.2;
        const gap = cellSize * GAP_TO_CELL_RATIO;
        const padding = gap / 2;
        const totalCellAndGapSize = cellSize + gap;
        return { top: padding + r * totalCellAndGapSize, left: padding + c * totalCellAndGapSize };
      }
  };
  
  const Cell = ({ number, owner, onClick, disabled, defender, isHighlighted, isIncorrect, isCircle, style, fontSizeClass }) => {
      const ownerColor = owner ? PLAYER_COLORS[owner].base : 'bg-slate-200 dark:bg-slate-700';
      const hoverEffect = owner || disabled ? '' : `hover:ring-4 ${PLAYER_COLORS[defender].ring} cursor-pointer`;
      const textClass = owner ? 'text-white' : 'text-slate-800 dark:text-slate-200';
      const disabledClass = disabled && !owner ? 'opacity-50 cursor-not-allowed' : '';
      const highlightClass = isHighlighted ? 'animate-pulse-highlight' : '';
      const incorrectClass = isIncorrect ? 'animate-flash-red' : '';
      const shapeClass = isCircle ? 'rounded-full' : 'rounded-lg';
      return (
        React.createElement('div', {
          style: style,
          onClick: owner || disabled ? undefined : onClick,
          className: `absolute flex items-center justify-center shadow-md transition-all duration-300 transform hover:scale-105 ${shapeClass} ${ownerColor} ${hoverEffect} ${disabledClass} ${highlightClass} ${incorrectClass}`
        }, React.createElement('span', { className: `font-bold ${fontSizeClass} ${textClass}` }, number))
      );
  };
  
  const fontSizeClass = isHexagonalLayout ? 'text-xl' : 'text-2xl md:text-3xl';
  
  return (
    React.createElement('div', { className: `p-4 bg-white dark:bg-slate-800 rounded-2xl shadow-xl transition-opacity duration-300 ${disabled ? 'opacity-70' : ''}`},
        React.createElement('div', { ref: gridRef, className: "relative w-full", style: { height: containerSize.height } },
          board.map((row, r) =>
              row.map((cell, c) => {
                  const isHighlighted = highlightedLines.some(line => line.coords.some(coord => coord.r === r && coord.c === c));
                  const isIncorrect = incorrectCell?.r === r && incorrectCell?.c === c;
                  const position = getCellPosition(r, c);
                  const style = { ...position, width: cellSize, height: cellSize };
                  return React.createElement(Cell, {
                          key: `${r}-${c}`, number: cell.number, owner: cell.owner, onClick: () => onCellClick(r, c),
                          disabled: disabled, defender: defender, isHighlighted: isHighlighted, isIncorrect: isIncorrect,
                          isCircle: isHexagonalLayout, style: style, fontSizeClass: fontSizeClass
                  });
              })
          ),
          React.createElement(WinningLinesOverlay, { lines: winningLines, highlightedLines: highlightedLines, gridSize: gridSize, is3P: isHexagonalLayout, cellSize: cellSize, getCellPosition: getCellPosition }),
          scorePopup && (() => {
            const pos = getCellPosition(scorePopup.r, scorePopup.c);
            const style = { position: 'absolute', top: `${pos.top + cellSize / 2}px`, left: `${pos.left + cellSize / 2}px`, transform: 'translate(-50%, -50%)' };
             return React.createElement(ScorePopup, { key: scorePopup.key, points: scorePopup.points, style: style });
          })()
        )
    )
  );
};

const FactorModal = ({ isOpen, numberToSolve, attackingFactor, minFactor, maxFactor, onClose, onSubmit }) => {
  const { useState, useEffect, useRef } = React;
  const [factor2, setFactor2] = useState('');
  const [error, setError] = useState(null);
  const input2Ref = useRef(null);
  useEffect(() => {
    if (isOpen) {
      setFactor2('');
      setError(null);
      setTimeout(() => input2Ref.current?.focus(), 100);
    }
  }, [isOpen]);
  if (!isOpen) return null;
  const handleSubmit = (e) => {
    e.preventDefault();
    const f2 = parseInt(factor2, 10);
    if (isNaN(f2)) {
      setError('Veuillez entrer un nombre.');
      return;
    }
    if (f2 > maxFactor || f2 < minFactor) {
        setError(`Le facteur doit être entre ${minFactor} et ${maxFactor}.`);
        return;
    }
    onSubmit(f2);
  };
  return (
    React.createElement('div', { className: "fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4" },
      React.createElement('div', { className: "bg-white dark:bg-slate-800 rounded-2xl shadow-2xl p-8 w-full max-w-sm text-center transform transition-all", onClick: (e) => e.stopPropagation() },
        React.createElement('h2', { className: "text-2xl font-bold mb-2 text-slate-900 dark:text-white" }, "Complétez la multiplication :"),
        React.createElement('p', { className: "text-6xl font-black text-indigo-600 dark:text-indigo-400 mb-6" }, numberToSolve),
        React.createElement('form', { onSubmit: handleSubmit, className: "space-y-4" },
          React.createElement('div', { className: "flex items-center justify-center space-x-4" },
            React.createElement('span', { className: "w-24 p-3 text-2xl font-bold text-center bg-slate-100 dark:bg-slate-700 rounded-lg dark:text-white" }, attackingFactor),
            React.createElement('span', { className: "text-3xl font-bold text-slate-500 dark:text-slate-400" }, "×"),
            React.createElement('input', { ref: input2Ref, type: "number", value: factor2, onChange: (e) => setFactor2(e.target.value), className: "w-24 p-3 text-2xl font-bold text-center bg-slate-200 dark:bg-slate-700 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:outline-none dark:text-white" })
          ),
          error && React.createElement('p', { className: "text-red-500 text-sm mt-2" }, error),
          React.createElement('div', { className: "flex space-x-4 pt-4" },
             React.createElement('button', { type: "button", onClick: onClose, className: "w-full py-3 text-lg font-bold bg-slate-300 dark:bg-slate-600 text-slate-800 dark:text-slate-200 rounded-lg hover:bg-slate-400 dark:hover:bg-slate-500 transition" }, "Annuler"),
            React.createElement('button', { type: "submit", className: "w-full py-3 text-lg font-bold text-white bg-green-600 rounded-lg hover:bg-green-700 transition" }, "Vérifier")
          )
        )
      )
    )
  );
};

const RulesModal = ({ isOpen, onClose }) => {
  if (!isOpen) return null;
  return (
    React.createElement('div', { className: "fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4", onClick: onClose },
      React.createElement('div', { className: "bg-white dark:bg-slate-800 rounded-2xl shadow-2xl p-8 w-full max-w-lg text-slate-800 dark:text-slate-200 transform transition-all", onClick: (e) => e.stopPropagation() },
        React.createElement('h2', { className: "text-3xl font-bold mb-6 text-center text-slate-900 dark:text-white" }, "Règles du jeu Multiplicat"),
        React.createElement('div', { className: "space-y-4 text-left max-h-[70vh] overflow-y-auto pr-2" },
          React.createElement('div', null,
            React.createElement('h3', { className: "text-xl font-semibold text-indigo-600 dark:text-indigo-400" }, "But du jeu :"),
            React.createElement('p', null, "Le but est de marquer le plus de points en alignant tes jetons de couleur sur la grille. Tu peux faire des lignes de 3, 4 ou 5 jetons.")
          ),
          React.createElement('div', null,
            React.createElement('h3', { className: "text-xl font-semibold text-indigo-600 dark:text-indigo-400" }, "Comment jouer ?"),
            React.createElement('p', null, "À chaque tour, il y a un ", React.createElement('strong', { className: "text-yellow-500" }, "Attaquant"), " et un ", React.createElement('strong', { className: "text-cyan-400" }, "Défenseur"), "."),
            React.createElement('ol', { className: "list-decimal list-inside mt-2 space-y-1 pl-4" },
              React.createElement('li', null, "L'", React.createElement('strong', null, "Attaquant"), " choisit une table de multiplication pour le Défenseur (par exemple, la table de 7)."),
              React.createElement('li', null, "Le ", React.createElement('strong', null, "Défenseur"), " choisit un nombre sur la grille qui est dans cette table (par exemple, 42)."),
              React.createElement('li', null, "Le ", React.createElement('strong', null, "Défenseur"), " doit alors donner le deuxième facteur de la multiplication (pour 42, si la table est 7, il faut répondre 6, car 7 × 6 = 42).")
            )
          ),
          React.createElement('div', null,
            React.createElement('h3', { className: "text-xl font-semibold text-indigo-600 dark:text-indigo-400" }, "Marquer des points :"),
            React.createElement('ul', { className: "list-disc list-inside mt-2 space-y-2 pl-4" },
              React.createElement('li', null, React.createElement('strong', null, "Bonne réponse :"), " Placer un jeton sur la grille rapporte ", React.createElement('strong', null, "1 point"), "."),
              React.createElement('li', null, React.createElement('strong', null, "Mauvaise réponse :"), " Une mauvaise réponse coûte ", React.createElement('strong', null, "1 point"), "."),
              React.createElement('li', null, React.createElement('strong', null, "Points d'alignement :"), " Des points supplémentaires sont accordés pour la création ou l'extension de lignes. La valeur totale de chaque alignement est :",
                React.createElement('ul', { className: "list-['-_'] list-inside ml-6 mt-1 space-y-1" },
                    React.createElement('li', null, "Ligne de 3 : ", React.createElement('strong', null, "1 point")),
                    React.createElement('li', null, "Ligne de 4 : ", React.createElement('strong', null, "3 points")),
                    React.createElement('li', null, "Ligne de 5 : ", React.createElement('strong', null, "10 points"))
                )
              ),
               React.createElement('li', { className: "pt-1" }, React.createElement('small', null, React.createElement('em', null, "Note : Si vous étendez une ligne (ex: de 3 à 4), vous gagnez la différence de points (ici, 3 - 1 = 2 points bonus).")))
            )
          ),
          React.createElement('div', null,
            React.createElement('h3', { className: "text-xl font-semibold text-indigo-600 dark:text-indigo-400" }, "Fin de la partie :"),
            React.createElement('p', null, "La partie se termine quand toute la grille est remplie. Le joueur avec le score le plus élevé gagne !")
          )
        ),
        React.createElement('div', { className: "mt-8 text-center" },
            React.createElement('button', { onClick: onClose, className: "w-1/2 py-3 text-lg font-bold text-white bg-indigo-600 rounded-lg hover:bg-indigo-700 transition" }, "J'ai compris !")
        )
      )
    )
  );
};

const PlayerPanel = ({ player, displayName, score, role, isActive, moves, isAi, isSetupPhase, availableFactors, onSelectFactor, onPlayerClick, onNameChange }) => {
  const playerMoves = moves.filter(move => move.player === player);
  const color = PLAYER_COLORS[player];
  const isChoosingFactor = role === 'attacker' && !!onSelectFactor;
  const RobotIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", viewBox: "0 0 20 20", fill: "currentColor" },
    React.createElement('path', { fillRule: "evenodd", d: "M10 2a8 8 0 100 16 8 8 0 000-16zM5 10a1 1 0 011-1h8a1 1 0 110 2H6a1 1 0 01-1-1zm1 4a1 1 0 100 2h6a1 1 0 100-2H6z", clipRule: "evenodd" }),
    React.createElement('path', { d: "M9 4.5a1 1 0 11-2 0 1 1 0 012 0zM13 4.5a1 1 0 11-2 0 1 1 0 012 0z" })
  );
  const HumanIcon = () => React.createElement('svg', { xmlns: "http://www.w3.org/2000/svg", className: "h-5 w-5", viewBox: "0 0 20 20", fill: "currentColor" },
      React.createElement('path', { fillRule: "evenodd", d: "M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z", clipRule: "evenodd" })
  );
  if (isSetupPhase) {
    return React.createElement('div', { onClick: () => onPlayerClick?.(player), className: "p-4 bg-white dark:bg-slate-800 rounded-2xl shadow-xl space-y-3 cursor-pointer ring-2 ring-transparent hover:ring-indigo-500 transition-all" },
      React.createElement('div', { className: "flex justify-between items-center" },
        React.createElement('h3', { className: `text-xl font-bold ${color.text}` }, player),
        React.createElement('div', { className: "flex items-center gap-2 text-sm font-semibold px-3 py-1 rounded-full bg-slate-200 dark:bg-slate-700 text-slate-600 dark:text-slate-300" },
          isAi ? React.createElement(RobotIcon) : React.createElement(HumanIcon),
          React.createElement('span', null, isAi ? 'IA' : 'Humain')
        )
      ),
      React.createElement('div', { className: "space-y-1" },
        React.createElement('label', { htmlFor: `player-name-${player}`, className: "text-sm font-medium text-slate-600 dark:text-slate-400" }, "Prénom du joueur"),
        React.createElement('input', { id: `player-name-${player}`, type: "text", value: displayName,
          onChange: (e) => { e.stopPropagation(); onNameChange?.(player, e.target.value); },
          onClick: (e) => e.stopPropagation(),
          className: "w-full px-3 py-2 bg-slate-100 dark:bg-slate-700 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:outline-none dark:text-white",
          placeholder: "Entrez un nom"
        })
      ),
      React.createElement('p', { className: "text-xs text-center text-slate-500 dark:text-slate-400 pt-1" }, "Cliquez pour changer le type (Humain/IA)")
    );
  }
  const getBorderColorClass = () => {
    if (!isActive || !role) return 'border-transparent';
    return role === 'attacker' ? 'border-yellow-400' : 'border-cyan-400';
  };
  const getRingClass = () => {
    if (isSetupPhase || !isActive || !role) return 'ring-transparent';
    const colorClass = role === 'attacker' ? 'ring-yellow-400' : 'ring-cyan-400';
    return `ring-4 ${colorClass} animate-pulse-ring`;
  };
  const iconColorClass = role === 'attacker' ? 'text-yellow-500' : 'text-cyan-400';
  return (
    React.createElement('div', { className: `rounded-2xl shadow-xl transition-all duration-300 w-full max-w-xs ${getRingClass()}` },
      React.createElement('div', { className: "bg-white dark:bg-slate-800 rounded-xl w-full h-full flex flex-col" },
        React.createElement('div', { className: `p-4 border-b-4 ${getBorderColorClass()}` },
          React.createElement('div', { className: "flex justify-between items-center" },
            React.createElement('div', { className: "flex items-center gap-2" },
              isActive && React.createElement('svg', { className: `w-5 h-5 ${iconColorClass}`, viewBox: "0 0 20 20", fill: "currentColor" }, React.createElement('path', { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-8.707l-3-3a1 1 0 00-1.414 1.414L10.586 9H7a1 1 0 100 2h3.586l-1.293 1.293a1 1 0 101.414 1.414l3-3a1 1 0 000-1.414z", clipRule: "evenodd" })),
              isAi && React.createElement(RobotIcon),
              React.createElement('h2', { className: `text-2xl font-bold ${color.text}` }, displayName)
            ),
            React.createElement('div', { className: "flex items-center gap-4" },
                role && React.createElement('span', { className: `px-3 py-1 text-sm font-bold text-white rounded-full ${role === 'attacker' ? 'bg-yellow-500' : 'bg-cyan-500'}` }, role === 'attacker' ? 'Attaquant' : 'Défenseur'),
                React.createElement(AnimatedScore, { targetScore: score })
            )
          )
        ),
        React.createElement('div', { className: "p-4 space-y-2 flex-grow overflow-y-auto max-h-80" },
          isChoosingFactor && React.createElement('div', { className: "mb-4 animate-fade-in-down" },
              React.createElement('h3', { className: "text-lg font-semibold text-yellow-500 dark:text-yellow-400 border-b pb-2 mb-3" }, "Choisir une table :"),
              availableFactors && availableFactors.length > 0 ?
                React.createElement('div', { className: "grid grid-cols-4 gap-2" },
                  availableFactors.map(factor => React.createElement('button', { key: factor, onClick: () => onSelectFactor(factor), className: "p-2 text-center font-bold bg-slate-200 dark:bg-slate-700 rounded-md hover:bg-indigo-600 hover:text-white transition-all transform hover:scale-110" }, factor))
                ) :
                React.createElement('p', { className: "text-slate-500 dark:text-slate-400 italic text-sm" }, "Aucune table disponible.")
            ),
          React.createElement('h3', { className: "text-lg font-semibold text-slate-600 dark:text-slate-300 border-b pb-2 mb-2" }, "Coups :"),
          playerMoves.length === 0 ? React.createElement('p', { className: "text-slate-500 dark:text-slate-400 italic text-sm" }, "Aucun coup joué.") :
            [...playerMoves].reverse().map((move, index) => React.createElement('div', { key: index, className: "text-slate-600 dark:text-slate-300 bg-slate-100 dark:bg-slate-700 p-2 rounded-md text-center" },
                React.createElement('span', { className: "font-mono" }, `${move.factor1} × ${move.factor2} = `),
                React.createElement('span', { className: "font-bold text-lg" }, move.number)
              ))
        )
      )
    )
  );
};

const ScoreBoard = ({ scores, players, currentPlayer, onNewGame }) => {
  return (
    React.createElement('div', { className: "w-full p-4 bg-white dark:bg-slate-800 rounded-2xl shadow-xl flex flex-wrap justify-between items-center gap-4" },
      React.createElement('div', { className: "flex items-center gap-4 md:gap-6 flex-wrap" },
        players.map(player => React.createElement('div', {
            key: player,
            className: `p-3 rounded-lg flex items-center gap-3 transition-all duration-300 ring-4 ${currentPlayer === player ? `${PLAYER_COLORS[player].ring}` : 'ring-transparent'}`
          },
          React.createElement('span', { className: `text-xl font-bold ${PLAYER_COLORS[player].text}` }, player),
          React.createElement(AnimatedScore, { targetScore: scores[player] })
        ))
      ),
      React.createElement('button', {
        onClick: onNewGame,
        className: "px-6 py-3 text-lg font-bold text-white bg-indigo-600 rounded-lg shadow-lg hover:bg-indigo-700 transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-indigo-300"
      }, "Nouvelle Partie")
    )
  );
};

const GameControls = ({ numPlayers, onNumPlayersChange, level, onLevelChange, onStartGame, onShowRules, onPrint }) => {
  const handleStart = () => {
    const gridSize = numPlayers === 2 ? 5 : 7;
    onStartGame(numPlayers, level, gridSize);
  };
  return (
    React.createElement('div', { className: "p-6 bg-white dark:bg-slate-800 rounded-2xl shadow-xl space-y-6" },
      React.createElement('h2', { className: "text-3xl font-bold text-center text-slate-900 dark:text-white" }, "Nouvelle Partie"),
      React.createElement('div', { className: "space-y-2" },
        React.createElement('label', { className: "text-lg font-semibold text-slate-700 dark:text-slate-300" }, "Nombre de joueurs"),
        React.createElement('div', { className: "flex gap-4" },
          [2, 3].map(n => React.createElement('button', {
              key: n, onClick: () => onNumPlayersChange(n),
              className: `flex-1 py-3 text-lg font-bold rounded-lg transition-all ${numPlayers === n ? 'bg-indigo-600 text-white ring-4 ring-indigo-300' : 'bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600'}`
            }, `${n} Joueurs`))
        )
      ),
      React.createElement('div', { className: "space-y-3" },
        React.createElement('label', { className: "text-lg font-semibold text-slate-700 dark:text-slate-300" }, "Niveau de difficulté"),
        Object.entries(LEVEL_CONFIG).map(([levelKey, config]) => {
          const levelNum = parseInt(levelKey);
          return React.createElement('div', { key: levelKey, className: "relative group" },
              React.createElement('button', {
                onClick: () => onLevelChange(levelNum),
                className: `w-full text-center p-4 rounded-lg border-2 transition-all font-bold ${level === levelNum ? 'bg-indigo-100 dark:bg-indigo-900/50 border-indigo-500' : 'bg-slate-100 dark:bg-slate-700 border-transparent hover:border-slate-300 dark:hover:border-slate-500'}`
              }, `Niveau ${levelKey}`),
              React.createElement('div', { className: "absolute bottom-full left-1/2 -translate-x-1/2 mb-2 w-64 p-3 bg-slate-800 text-white text-sm rounded-lg shadow-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-10" },
                config.description,
                React.createElement('div', { className: "absolute left-1/2 -translate-x-1/2 top-full w-0 h-0 border-x-8 border-x-transparent border-t-8 border-t-slate-800" })
              )
            )
        })
      ),
      React.createElement('div', { className: "pt-4 space-y-3" },
        React.createElement('button', { onClick: handleStart, className: "w-full py-4 text-xl font-bold text-white bg-green-600 rounded-lg shadow-lg hover:bg-green-700 transition-transform transform hover:scale-105" }, "Commencer à jouer"),
        React.createElement('div', { className: "flex gap-4" },
           React.createElement('button', { onClick: onShowRules, className: "w-full py-3 text-lg font-semibold bg-slate-200 dark:bg-slate-700 text-slate-800 dark:text-slate-200 rounded-lg hover:bg-slate-300 dark:hover:bg-slate-600 transition" }, "Règles du jeu"),
          React.createElement('button', { onClick: onPrint, className: "w-full py-3 text-lg font-semibold bg-slate-200 dark:bg-slate-700 text-slate-800 dark:text-slate-200 rounded-lg hover:bg-slate-300 dark:hover:bg-slate-600 transition" }, "Imprimer une grille")
        )
      )
    )
  );
};

const AiControlModal = ({ isOpen, onClose, player, config, onSave, isAiChangeable }) => {
  const { useState, useEffect } = React;
  const [isAi, setIsAi] = useState(false);
  const [difficulty, setDifficulty] = useState(1);
  const [name, setName] = useState('');
  useEffect(() => {
    if (isOpen && config) {
      setIsAi(config.isAi);
      setDifficulty(config.difficulty);
      setName(config.name);
    }
  }, [isOpen, config]);
  if (!isOpen || !player || !config) return null;
  const handleSave = () => {
    onSave(player, { isAi, difficulty, name });
  };
  const difficultyDescriptions = {
    1: "Niveau 1 : L'IA choisit ses coups au hasard.",
    2: "Niveau 2 : L'IA essaie de faire des alignements de 3 jetons.",
    3: "Niveau 3 : L'IA joue pour gagner et essaie de bloquer l'adversaire."
  };
  return (
    React.createElement('div', { className: "fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 p-4", onClick: onClose },
      React.createElement('div', { className: "bg-white dark:bg-slate-800 rounded-2xl shadow-2xl p-8 w-full max-w-md text-slate-800 dark:text-slate-200 transform transition-all", onClick: (e) => e.stopPropagation() },
        React.createElement('h2', { className: "text-3xl font-bold mb-6 text-center text-slate-900 dark:text-white" }, `Configurer le joueur ${player}`),
        React.createElement('div', { className: "space-y-6" },
           React.createElement('div', null,
              React.createElement('label', { htmlFor: "player-name-modal", className: "text-lg font-medium text-slate-700 dark:text-slate-300" }, "Prénom du Joueur"),
              React.createElement('input', { id: "player-name-modal", type: "text", value: name, onChange: (e) => setName(e.target.value), className: "mt-2 w-full px-4 py-2 bg-slate-100 dark:bg-slate-700 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:outline-none dark:text-white", placeholder: "Entrez un nom" })
          ),
          React.createElement('div', { className: "flex items-center justify-between p-4 bg-slate-100 dark:bg-slate-700 rounded-lg" },
            React.createElement('span', { className: `text-lg font-medium ${!isAiChangeable ? 'text-slate-400 dark:text-slate-500' : ''}` }, "Activer l'Intelligence Artificielle"),
            React.createElement('button', { onClick: () => isAiChangeable && setIsAi(!isAi), disabled: !isAiChangeable, className: `relative inline-flex items-center h-6 rounded-full w-11 transition-colors ${isAi ? 'bg-indigo-600' : 'bg-slate-300 dark:bg-slate-500'} ${!isAiChangeable ? 'cursor-not-allowed' : ''}` },
              React.createElement('span', { className: `inline-block w-4 h-4 transform bg-white rounded-full transition-transform ${isAi ? 'translate-x-6' : 'translate-x-1'}` })
            )
          ),
          !isAiChangeable && React.createElement('p', { className: "text-sm text-yellow-600 dark:text-yellow-400 -mt-4 px-1" }, "Le premier joueur doit être humain."),
          isAi && React.createElement('div', { className: "space-y-4 animate-fade-in-down" },
              React.createElement('h3', { className: "text-lg font-medium" }, "Niveau de difficulté de l'IA"),
              React.createElement('div', { className: "space-y-3" },
                [1, 2, 3].map(level => React.createElement('button', {
                    key: level, onClick: () => setDifficulty(level),
                    className: `w-full text-left p-4 rounded-lg border-2 transition-all ${difficulty === level ? 'bg-indigo-100 dark:bg-indigo-900/50 border-indigo-500' : 'bg-slate-100 dark:bg-slate-700 border-transparent hover:border-slate-300 dark:hover:border-slate-500'}`
                  },
                  React.createElement('p', { className: "font-bold" }, `Niveau ${level}`),
                  React.createElement('p', { className: "text-sm text-slate-600 dark:text-slate-400" }, difficultyDescriptions[level])
                ))
              )
            )
        ),
        React.createElement('div', { className: "mt-8 flex justify-end space-x-4" },
            React.createElement('button', { onClick: onClose, className: "px-6 py-3 text-lg font-semibold bg-slate-200 dark:bg-slate-600 text-slate-800 dark:text-slate-200 rounded-lg hover:bg-slate-300 dark:hover:bg-slate-500 transition" }, "Annuler"),
            React.createElement('button', { onClick: handleSave, className: "px-6 py-3 text-lg font-bold text-white bg-green-600 rounded-lg hover:bg-green-700 transition" }, "Sauvegarder")
        )
      )
    )
  );
};

const PrintableGrid = ({ board, levelConfig, numPlayers }) => {
  const isHexagonal = numPlayers === 3;
  const gridSize = board.length;
  const players = numPlayers === 3 ? ['Rouge', 'Bleu', 'Vert'] : ['Rouge', 'Bleu'];
  const leftPlayers = [players[0]];
  const rightPlayers = [players[1]];
  const bottomPlayer = numPlayers === 3 ? [players[2]] : [];
  const containerWidth = 400;

  const renderSquareGrid = () => {
    const GAP_FRACTION = 0.25;
    const totalDivisionsWithGaps = gridSize + (gridSize - 1) * GAP_FRACTION;
    const cellSize = containerWidth / totalDivisionsWithGaps;
    const gap = cellSize * GAP_FRACTION;
    const totalGridSize = containerWidth;
    const getCellCenter = (r, c) => ({ x: c * (cellSize + gap) + cellSize / 2, y: r * (cellSize + gap) + cellSize / 2 });
    return (
        React.createElement('div', { style: { position: 'relative', width: `${totalGridSize}px`, height: `${totalGridSize}px` } },
            React.createElement('svg', { width: "100%", height: "100%", style: { position: 'absolute', top: 0, left: 0, zIndex: 1 } },
                Array.from({ length: gridSize }).map((_, r) =>
                    Array.from({ length: gridSize }).map((_, c) => {
                        const lines = [];
                        const start = getCellCenter(r, c);
                        if (c < gridSize - 1) {
                            const end = getCellCenter(r, c + 1);
                            lines.push(React.createElement('line', { key: `${r}-${c}-h`, x1: start.x, y1: start.y, x2: end.x, y2: end.y, stroke: "#ccc", strokeWidth: "2" }));
                        }
                        if (r < gridSize - 1) {
                            const end = getCellCenter(r + 1, c);
                            lines.push(React.createElement('line', { key: `${r}-${c}-v`, x1: start.x, y1: start.y, x2: end.x, y2: end.y, stroke: "#ccc", strokeWidth: "2" }));
                        }
                        return lines;
                    })
                )
            ),
            board.map((row, r) =>
                row.map((cell, c) => (
                    React.createElement('div', { key: `${r}-${c}`, style: {
                        position: 'absolute', top: `${r * (cellSize + gap)}px`, left: `${c * (cellSize + gap)}px`,
                        width: `${cellSize}px`, height: `${cellSize}px`, border: '2px solid #333',
                        display: 'flex', alignItems: 'center', justifyContent: 'center',
                        fontSize: '20px', fontWeight: 'bold', boxSizing: 'border-box', background: '#fff', zIndex: 2,
                    }}, cell.number)
                ))
            )
        )
    );
  };
  const renderHexagonalGrid = () => {
    const ROW_OVERLAP_FACTOR = 0.134;
    const STAGGER_OFFSET_FACTOR = 0.5;
    const effectiveGridWidthInCells = gridSize + STAGGER_OFFSET_FACTOR;
    const cellSize = containerWidth / effectiveGridWidthInCells;
    const rowHeight = cellSize * (1 - ROW_OVERLAP_FACTOR);
    const containerHeight = cellSize + (gridSize - 1) * rowHeight;
    return (
      React.createElement('div', { style: { position: 'relative', width: `${containerWidth}px`, height: `${containerHeight}px`, margin: '0 auto' } },
        board.map((row, r) =>
          row.map((cell, c) => {
            const isStaggeredRow = r % 2 !== 0;
            const xOffset = isStaggeredRow ? cellSize * STAGGER_OFFSET_FACTOR : 0;
            const left = c * cellSize + xOffset;
            const top = r * rowHeight;
            return (
              React.createElement('div', { key: `${r}-${c}`, style: {
                position: 'absolute', top: `${top}px`, left: `${left}px`,
                width: `${cellSize}px`, height: `${cellSize}px`, border: '1px solid #999', borderRadius: '50%',
                display: 'flex', alignItems: 'center', justifyContent: 'center',
                fontSize: '16px', fontWeight: 'bold', boxSizing: 'border-box'
              }}, cell.number)
            );
          })
        )
      )
    );
  };
  const renderScoreSheet = (player, playerNum, isBottomPlayer) => {
    const numLines = isBottomPlayer ? 15 : 20;
    const renderScoreLines = () => {
        const numColumns = isBottomPlayer ? 3 : 2;
        const linesPerColumn = Math.ceil(numLines / numColumns);
        const columns = [];
        for (let col = 0; col < numColumns; col++) {
            const start = col * linesPerColumn;
            const end = Math.min((col + 1) * linesPerColumn, numLines);
            if (start >= end) continue;
            columns.push(
                React.createElement('div', { key: col, style: { display: 'flex', flexDirection: 'column', gap: '8px', flex: 1 } },
                    Array.from({ length: end - start }).map((_, i) => (
                        React.createElement('div', { key: start + i, style: { borderBottom: '1px dotted #999', height: '16px' } })
                    ))
                )
            );
        }
        return React.createElement('div', { style: { display: 'flex', gap: '20px' } }, columns);
    };
    return (
        React.createElement('div', { style: { border: '1px solid #ccc', padding: '10px', borderRadius: '8px' } },
            React.createElement('h3', { style: { paddingBottom: '8px', marginBottom: '10px', fontSize: '16px', fontWeight: 'bold', borderBottom: '1px solid #ccc' } },
                `Joueur ${playerNum} (${player})`
            ),
            React.createElement('div', { style: { fontSize: '12px' } }, renderScoreLines()),
            React.createElement('div', { style: { marginTop: '15px', fontSize: '14px', fontWeight: 'bold' } },
                "Score final: ........................"
            )
        )
    );
  };
  return (
    React.createElement('div', { style: { fontFamily: 'Arial, sans-serif', padding: '20px', color: '#000', background: '#fff', width: '100%', display: 'flex', flexDirection: 'column', justifyContent: 'space-between', gap: '20px', minHeight: '100%' } },
      React.createElement('div', { style: { display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', gap: '30px' } },
        React.createElement('div', { style: { flex: 1 } }, leftPlayers.map(player => renderScoreSheet(player, players.indexOf(player) + 1, false))),
        React.createElement('div', { style: { flex: '0 1 auto', display: 'flex', flexDirection: 'column', alignItems: 'center' } },
          React.createElement('h1', { style: { fontSize: '28px', fontWeight: 'bold', textAlign: 'center', marginBottom: '10px', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '10px' } },
            React.createElement('span', null, "Multiplicat"),
            React.createElement('span', { style: { fontSize: '16px', fontWeight: 'normal', color: '#555', border: '1px solid #ccc', padding: '2px 8px', borderRadius: '6px' } }, `${numPlayers} joueurs`)
          ),
          React.createElement('p', { style: { textAlign: 'center', fontSize: '14px', marginBottom: '20px', color: '#555' } },
            React.createElement('strong', null, "Niveau :"), ` ${levelConfig.description.split(':')[0]} | `,
            React.createElement('strong', null, "Tables de l'attaquant :"), ` ${levelConfig.attackerRange.min} à ${levelConfig.attackerRange.max}`
          ),
          isHexagonal ? renderHexagonalGrid() : renderSquareGrid(),
          React.createElement('div', { style: { marginTop: '25px', border: '1px solid #ccc', padding: '10px 15px', borderRadius: '8px', fontSize: '12px', textAlign: 'center' } },
            React.createElement('h4', { style: { fontWeight: 'bold', marginBottom: '5px' } }, "Rappel des points d'alignement :"),
            React.createElement('p', null, `Ligne de 3 : `, React.createElement('strong', null, `${POINTS_MAP[3]} point`), ` | Ligne de 4 : `, React.createElement('strong', null, `${POINTS_MAP[4]} points`), ` | Ligne de 5 : `, React.createElement('strong', null, `${POINTS_MAP[5]} points`))
          )
        ),
        React.createElement('div', { style: { flex: 1 } }, rightPlayers.map(player => renderScoreSheet(player, players.indexOf(player) + 1, false)))
      ),
      numPlayers === 3 && React.createElement('div', { style: { width: '100%', paddingTop: '10px', display: 'flex', justifyContent: 'center' } },
            React.createElement('div', { style: { width: '85%', maxWidth: '800px' } }, bottomPlayer.map(player => renderScoreSheet(player, players.indexOf(player) + 1, true)))
        )
    )
  );
};

// ===== From App.tsx =====
const App = () => {
    const { useState, useEffect, useCallback, useMemo, useRef } = React;
    const [gameState, setGameState] = useState('setup');
    const [numPlayers, setNumPlayers] = useState(2);
    const [players, setPlayers] = useState(['Rouge', 'Bleu']);
    const [scores, setScores] = useState({ Rouge: 0, Bleu: 0, Vert: 0 });
    const [board, setBoard] = useState([]);
    const [gameLevel, setGameLevel] = useState(1);
    const [gridSize, setGridSize] = useState(5);
    const [moves, setMoves] = useState([]);
    const [winningLines, setWinningLines] = useState([]);
    const [currentPlayerIndex, setCurrentPlayerIndex] = useState(0);
    const [attacker, setAttacker] = useState(null);
    const [defender, setDefender] = useState(null);
    const [attackingFactor, setAttackingFactor] = useState(null);
    const [selectedCell, setSelectedCell] = useState(null);
    const [isFactorModalOpen, setIsFactorModalOpen] = useState(false);
    const [isRulesModalOpen, setIsRulesModalOpen] = useState(false);
    const [isAiControlModalOpen, setIsAiControlModalOpen] = useState(false);
    const [playerToConfigure, setPlayerToConfigure] = useState(null);
    const [scorePopup, setScorePopup] = useState(null);
    const [incorrectCell, setIncorrectCell] = useState(null);
    const [highlightedLines, setHighlightedLines] = useState([]);
    const [boardForPrint, setBoardForPrint] = useState(null);
    const printContainerRef = useRef(null);
    const [playerConfigs, setPlayerConfigs] = useState({
        Rouge: { isAi: false, difficulty: 1, name: 'Joueur 1' },
        Bleu: { isAi: false, difficulty: 1, name: 'Joueur 2' },
        Vert: { isAi: false, difficulty: 1, name: 'Joueur 3' },
    });
    const levelConfig = useMemo(() => LEVEL_CONFIG[gameLevel], [gameLevel]);
    const availableFactors = useMemo(() => {
        const factors = [];
        for (let i = levelConfig.attackerRange.min; i <= levelConfig.attackerRange.max; i++) {
            factors.push(i);
        }
        return factors;
    }, [levelConfig]);
    useEffect(() => {
        setGridSize(numPlayers === 2 ? 5 : 7);
    }, [numPlayers]);
    const setupRoles = useCallback((playerIndex) => {
        const currentAttacker = players[playerIndex % players.length];
        const currentDefender = players[(playerIndex + 1) % players.length];
        setAttacker(currentAttacker);
        setDefender(currentDefender);
    }, [players]);
    const handleNewGame = useCallback(() => {
        setGameState('setup');
        setBoard([]);
        setScores({ Rouge: 0, Bleu: 0, Vert: 0 });
        setMoves([]);
        setWinningLines([]);
        setCurrentPlayerIndex(0);
        setAttacker(null);
        setDefender(null);
        setAttackingFactor(null);
    }, []);
    const handleStartGame = (num, level, size) => {
        const newPlayers = num === 3 ? ['Rouge', 'Bleu', 'Vert'] : ['Rouge', 'Bleu'];
        setPlayers(newPlayers);
        setNumPlayers(num);
        setGameLevel(level);
        setGridSize(size);
        setBoard(generateBoard(level, size, num));
        setGameState('playing');
        setupRoles(0);
    };
    const handlePlayerNameChange = (player, newName) => {
        setPlayerConfigs(prev => ({
            ...prev,
            [player]: { ...prev[player], name: newName }
        }));
    };
    const nextTurn = useCallback(() => {
        setAttackingFactor(null);
        setSelectedCell(null);
        setHighlightedLines([]);
        const nextIndex = currentPlayerIndex + 1;
        const isBoardFull = board.length > 0 && board.every(row => row.every(cell => cell.owner !== null));
        if (isBoardFull) {
            setGameState('gameOver');
            setAttacker(null);
            setDefender(null);
            return;
        }
        setCurrentPlayerIndex(nextIndex);
        setupRoles(nextIndex);
    }, [board, currentPlayerIndex, setupRoles]);
    const handleSelectFactor = (factor) => {
        if (attacker && playerConfigs[attacker].isAi) return;
        setAttackingFactor(factor);
    };
    const handleCellClick = (r, c) => {
        if (board[r][c].owner || !attackingFactor || (defender && playerConfigs[defender].isAi)) {
            return;
        }
        setSelectedCell({ r, c });
        setIsFactorModalOpen(true);
    };
    const handleSubmitFactor = useCallback((factor2) => {
        if (!selectedCell || !attackingFactor || !defender) return;
        const { r, c } = selectedCell;
        const numberToSolve = board[r][c].number;
        const isCorrect = attackingFactor * factor2 === numberToSolve;
        setIsFactorModalOpen(false);
        const oldScores = { ...scores };
        const oldLines = findWinningLines(board);
        if (isCorrect) {
            const newBoard = JSON.parse(JSON.stringify(board));
            newBoard[r][c].owner = defender;
            setBoard(newBoard);
            setMoves(prev => [...prev, { player: defender, number: numberToSolve, factor1: attackingFactor, factor2 }]);
            const newScores = calculateScores(newBoard);
            const newLines = findWinningLines(newBoard);
            setWinningLines(newLines);
            let scoreDelta = newScores[defender] - oldScores[defender];
            scoreDelta += 1;
            const totalPointsGained = scoreDelta;
            if (totalPointsGained > 0) {
                 setScorePopup({ points: totalPointsGained, r, c, key: Date.now() });
                 const oldLineKeys = new Set(oldLines.map(l => `${l.player}-${l.coords[0].r},${l.coords[0].c}-${l.coords[l.coords.length-1].r},${l.coords[l.coords.length-1].c}`));
                 const newlyFormedLines = newLines.filter(l => {
                    const key = `${l.player}-${l.coords[0].r},${l.coords[0].c}-${l.coords[l.coords.length-1].r},${l.coords[l.coords.length-1].c}`;
                    return !oldLineKeys.has(key) && l.player === defender;
                 });
                 setHighlightedLines(newlyFormedLines);
            }
            setScores(prev => ({ ...prev, [defender]: prev[defender] + totalPointsGained }));
        } else {
            setScores(prev => ({ ...prev, [defender]: Math.max(0, prev[defender] - 1) }));
            setIncorrectCell({r, c});
            setTimeout(() => setIncorrectCell(null), 1000);
        }
        setTimeout(() => nextTurn(), 1500);
    }, [selectedCell, attackingFactor, defender, board, scores, nextTurn]);
    const handlePrint = () => {
        const boardToPrint = generateBoard(gameLevel, gridSize, numPlayers);
        setBoardForPrint(boardToPrint);
    };
    useEffect(() => {
        if (boardForPrint && printContainerRef.current) {
            const { jsPDF } = window.jspdf;
            const elementToPrint = printContainerRef.current;
            const options = { scale: 2, useCORS: true, logging: false, width: elementToPrint.offsetWidth, height: elementToPrint.offsetHeight, backgroundColor: '#ffffff' };
            window.html2canvas(elementToPrint, options).then((canvas) => {
                const imgData = canvas.toDataURL('image/png');
                const imgWidth = canvas.width;
                const imgHeight = canvas.height;
                const pdf = new jsPDF({ orientation: imgWidth > imgHeight ? 'landscape' : 'portrait', unit: 'px', format: [imgWidth, imgHeight] });
                pdf.addImage(imgData, 'PNG', 0, 0, imgWidth, imgHeight);
                window.open(pdf.output('bloburl'), '_blank');
                setBoardForPrint(null);
            }).catch((err) => {
                console.error("Failed to generate PDF", err);
                setBoardForPrint(null);
            });
        }
    }, [boardForPrint]);
    useEffect(() => {
        if (gameState !== 'playing') return;
        const handleAiTurn = async () => {
            if (attacker && playerConfigs[attacker].isAi && !attackingFactor) {
                await new Promise(res => setTimeout(res, 1000));
                const factor = aiSelectFactor(availableFactors);
                setAttackingFactor(factor);
                return;
            }
            if (defender && playerConfigs[defender].isAi && attackingFactor && !selectedCell) {
                await new Promise(res => setTimeout(res, 1500));
                const opponents = players.filter(p => p !== defender);
                const bestMove = findBestAiMove(board, attackingFactor, levelConfig.defenderRange, defender, opponents, playerConfigs[defender].difficulty);
                if (bestMove) {
                    setSelectedCell({ r: bestMove.r, c: bestMove.c });
                    await new Promise(res => setTimeout(res, 500));
                    handleSubmitFactor(bestMove.factor2);
                } else {
                    nextTurn();
                }
            }
        };
        handleAiTurn();
    }, [gameState, attacker, defender, attackingFactor, selectedCell, playerConfigs, availableFactors, board, nextTurn, players, levelConfig, handleSubmitFactor]);
    
    if (gameState === 'setup') {
        return (
            React.createElement('div', { className: "min-h-screen bg-slate-100 dark:bg-slate-900 text-slate-800 dark:text-slate-200 p-4 sm:p-6 lg:p-8 flex items-center justify-center" },
                React.createElement('div', { className: "w-full max-w-4xl mx-auto space-y-8" },
                   React.createElement('div', { className: "text-center" },
                        React.createElement('h1', { className: "text-5xl font-extrabold text-slate-900 dark:text-white" }, "Multiplicat"),
                        React.createElement('p', { className: "mt-2 text-lg text-slate-600 dark:text-slate-400" }, "Le jeu de calcul pour maîtriser les multiplications !")
                    ),
                    React.createElement('div', { className: "grid md:grid-cols-2 gap-8 items-start" },
                        React.createElement(GameControls, {
                            numPlayers: numPlayers, onNumPlayersChange: setNumPlayers,
                            level: gameLevel, onLevelChange: setGameLevel,
                            onStartGame: handleStartGame, onShowRules: () => setIsRulesModalOpen(true), onPrint: handlePrint
                        }),
                        React.createElement('div', { className: "space-y-4" },
                             React.createElement('h3', { className: "text-xl font-bold text-center text-slate-900 dark:text-white" }, "Configuration des joueurs"),
                            (numPlayers === 2 ? ['Rouge', 'Bleu'] : ['Rouge', 'Bleu', 'Vert']).map(p => {
                                const player = p;
                                return React.createElement(PlayerPanel, {
                                        key: player, player: player, displayName: playerConfigs[player].name,
                                        score: 0, role: null, isActive: false, moves: [], isAi: playerConfigs[player].isAi,
                                        isSetupPhase: true,
                                        onPlayerClick: (pl) => { setPlayerToConfigure(pl); setIsAiControlModalOpen(true); },
                                        onNameChange: handlePlayerNameChange
                                    });
                            })
                        )
                    ),
                ),
                React.createElement(RulesModal, { isOpen: isRulesModalOpen, onClose: () => setIsRulesModalOpen(false) }),
                React.createElement(AiControlModal, {
                    isOpen: isAiControlModalOpen, onClose: () => setIsAiControlModalOpen(false),
                    player: playerToConfigure, config: playerToConfigure ? playerConfigs[playerToConfigure] : null,
                    onSave: (player, config) => {
                        setPlayerConfigs(prev => ({...prev, [player]: config}));
                        setIsAiControlModalOpen(false);
                    },
                    isAiChangeable: playerToConfigure !== 'Rouge'
                }),
                React.createElement('div', { ref: printContainerRef, style: { position: 'absolute', left: '-9999px', top: '-9999px', width: '1123px', background: 'white' } },
                   boardForPrint && React.createElement(PrintableGrid, { board: boardForPrint, levelConfig: levelConfig, numPlayers: numPlayers })
                )
            )
        );
    }

    return (
        React.createElement('div', { className: "min-h-screen bg-slate-100 dark:bg-slate-900 text-slate-800 dark:text-slate-200 p-4 sm:p-6 lg:p-8" },
            React.createElement('div', { className: "max-w-7xl mx-auto space-y-6" },
                React.createElement(ScoreBoard, { scores: scores, players: players, currentPlayer: attacker, onNewGame: handleNewGame }),
                React.createElement('div', { className: "grid lg:grid-cols-[1fr_2fr_1fr] gap-6 items-start" },
                    React.createElement('div', { className: "flex flex-col gap-6" },
                        React.createElement(PlayerPanel, {
                            player: players[0], displayName: playerConfigs[players[0]].name, score: scores[players[0]],
                            role: attacker === players[0] ? 'attacker' : (defender === players[0] ? 'defender' : null),
                            isActive: attacker === players[0] || defender === players[0],
                            moves: moves, isAi: playerConfigs[players[0]].isAi, isSetupPhase: false,
                            availableFactors: attacker === players[0] ? availableFactors : undefined,
                            onSelectFactor: handleSelectFactor
                        }),
                         numPlayers === 3 && players[2] && React.createElement(PlayerPanel, {
                                player: players[2], displayName: playerConfigs[players[2]].name, score: scores[players[2]],
                                role: attacker === players[2] ? 'attacker' : (defender === players[2] ? 'defender' : null),
                                isActive: attacker === players[2] || defender === players[2],
                                moves: moves, isAi: playerConfigs[players[2]].isAi, isSetupPhase: false,
                                availableFactors: attacker === players[2] ? availableFactors : undefined,
                                onSelectFactor: handleSelectFactor
                            })
                    ),
                    React.createElement('div', { className: "lg:col-start-2" },
                      React.createElement(GameBoardComponent, {
                          board: board, numPlayers: numPlayers, winningLines: winningLines, onCellClick: handleCellClick,
                          disabled: !attackingFactor || (defender !== null && playerConfigs[defender].isAi) || gameState === 'gameOver',
                          defender: defender || players[0], scorePopup: scorePopup, incorrectCell: incorrectCell, highlightedLines: highlightedLines
                      })
                    ),
                    React.createElement('div', { className: "lg:col-start-3" },
                         React.createElement(PlayerPanel, {
                            player: players[1], displayName: playerConfigs[players[1]].name, score: scores[players[1]],
                            role: attacker === players[1] ? 'attacker' : (defender === players[1] ? 'defender' : null),
                            isActive: attacker === players[1] || defender === players[1],
                            moves: moves, isAi: playerConfigs[players[1]].isAi, isSetupPhase: false,
                            availableFactors: attacker === players[1] ? availableFactors : undefined,
                            onSelectFactor: handleSelectFactor
                        })
                    )
                )
            ),
            selectedCell && defender && React.createElement(FactorModal, {
                    isOpen: isFactorModalOpen, onClose: () => setIsFactorModalOpen(false),
                    numberToSolve: board[selectedCell.r][selectedCell.c].number,
                    attackingFactor: attackingFactor, minFactor: levelConfig.defenderRange.min,
                    maxFactor: levelConfig.defenderRange.max, onSubmit: handleSubmitFactor
            })
        )
    );
};

// ===== From index.tsx =====
const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}
const root = ReactDOM.createRoot(rootElement);
root.render(
  React.createElement(React.StrictMode, null, React.createElement(App))
);

    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>